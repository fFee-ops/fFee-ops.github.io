---
title: 基于MySQL实现分布式锁
date: 2021-06-23 14:57:11
tags: 
categories: MySQL
---

<!--more-->

### 基于MySQL实现分布式锁

- [适用场景](#_2)
- [基于唯一索引实现](#_6)
- - [实现方式](#_7)
  - [优点](#_13)
  - [缺点](#_16)
- [在毫秒级的插入中，不能通过唯一性约束保证，如何实现分布式锁？](#_22)

# 适用场景

基于Mysql实现分布式锁，适用于对性能要求不高（用mysql实现性能肯定不如用redis、zookeeper实现），并且不希望因为要使用分布式锁而引入新组件。

# 基于唯一索引实现

## 实现方式

1.  获取锁时在数据库中insert一条数据，包括id、方法名\(唯一索引\)、线程名\(用于重入\)、重入计数
2.  获取锁如果成功则返回true
3.  获取锁的动作放在while循环中，周期性尝试获取锁直到结束或者可以定义方法来限定时间内获取锁
4.  释放锁的时候，delete对应的数据

## 优点

实现简单、易于理解

## 缺点

1.  这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。
2.  一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
3.  这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁，因为数据中数据已经存在了；

# 在毫秒级的插入中，不能通过唯一性约束保证，如何实现分布式锁？

个人认为可以通过乐观锁思想来为数据库表添加一个 version 字段来实现读取出数据时，将此版本号一同读出，之后更新都要比较版本号是否改变。

实际就是个`CAS`过程。