---
title: 过期删除策略&内存淘汰策略
date: 2020-09-06 11:02:35
tags: 
categories: Redis
---

# 1. 问题分析
①、如何设置Redis键的过期时间？
②、设置完一个键的过期时间后，到了这个时间，这个键还能获取到么？假如获取不到那这个键还占据着内存吗？
③、如何设置Redis的内存大小？当内存满了之后，Redis有哪些内存淘汰策略？我们又该如何选择？

# 2. 设置Redis键过期时间
Redis提供了四个命令来设置过期时间（生存时间）。
①、**EXPIRE** ：表示将键 key 的生存时间设置为 ttl 秒。
②、**PEXPIRE** ：表示将键 key 的生存时间设置为 ttl 毫秒。
③、**EXPIREAT** ：表示将键 key 的生存时间设置为 timestamp 所指定的秒数时间戳。
④、**PEXPIREAT** ：表示将键 key 的生存时间设置为 timestamp 所指定的毫秒数时间戳。
PS：在Redis内部实现中，前面三个设置过期时间的命令最后都会转换成最后一个PEXPIREAT 命令来完成。


另外补充两个知识点：
**一、移除键的过期时间**
PERSIST ：表示将key的过期时间移除。
**二、返回键的剩余生存时间**
TTL ：以秒的单位返回键 key 的剩余生存时间。
PTTL ：以毫秒的单位返回键 key 的剩余生存时间。

# 3. Redis过期时间的判定
在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个过期字典中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。

# 4. 过期删除策略
通常删除某个key，我们有如下三种方式进行处理。
①、定时删除
在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行
对其进行删除的操作。
②、惰性删除
设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们
就删掉它，反之返回该key。
③、定期删除
每隔一段时间，我们就对一些key进行检查，删除里面过期的key。

## 4.1 Redis过期删除策略
Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用

**惰性删除**：Redis的惰性删除策略由 `db.c/expireIfNeeded`函数实现，所有键读写命令执行之前都会调用`expireIfNeeded` 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。 【这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。】

**定期删除**：由`redis.c/activeExpireCycle` 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。【定期删除对内存更加友好】


注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键


**但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了**

redis用Redis 内存淘汰机制来解决这个问题。

# 5. 内存淘汰策略
## 5.1 设置Redis最大内存
在配置文件redis.conf 中，可以通过参数 maxmemory 来设定最大内存：
![在这里插入图片描述](https://img-blog.csdnimg.cn/752615edef6e4f14810a62d41bba46d5.png)
不设定该参数默认是无限制的，但是通常会设定其为物理内存的**四分之三**


## 5.2 设置内存淘汰方式
当现有内存大于 maxmemory 时，便会触发redis主动淘汰内存方式，通过设置 `maxmemory-policy` 来指定内存淘汰方式。有如下几种淘汰方式：
Redis 提供 6 种数据淘汰策略：

1. **volatile-lru**（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

7. **volatile-lfu**（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
8. **allkeys-lfu**（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key