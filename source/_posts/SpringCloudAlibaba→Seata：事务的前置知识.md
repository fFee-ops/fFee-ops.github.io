---
title: SpringCloudAlibaba→Seata：事务的前置知识
date: 2022-01-06 17:31:34
tags: 数据库 sql java
categories: SpringCloudAlibaba
---

<!--more-->

### Seata：事务的前置知识

- [1、事务概念](#1_2)
- - [1.1 事务简介](#11__11)
  - [1.2 本地事务](#12__15)
  - [1.3 分布式事务](#13__26)
  - - [1.3.1 跨库事务](#131__29)
    - [1.3.2 分库分表事务](#132__32)
    - [1.3.3 跨应用事务](#133__39)
- [2、分布式理论](#2_45)
- - [2.1 CAP原理](#21_CAP_48)
  - [2.2 BASE理论](#22_BASE_63)
  - [2.3 刚柔事务](#23__79)
- [3、常用事务解决方案模型](#3_91)
- - [3.1 DTP模型](#31_DTP_94)
  - [3.2 2PC/3PC](#32_2PC3PC_103)
  - - [2PC](#2PC_104)
    - [3PC](#3PC_139)
    - [2PC VS 3PC](#2PC_VS_3PC_161)
  - [3.3 TCC](#33_TCC_167)
  - [3.4 MQ分布式事务](#34_MQ_180)

# 1、事务概念

在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本\(replica\)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的 CRUD 等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。分布式事务在现在遍地都是分布式部署的系统中几乎是必要的。

我们的项目用到了数据库，也和事务有关，我们先分析一下项目的问题，再描述一下事务。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/5a474967687443cbb4d5f62ac7407c65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)

如上图，如果用户打车成功，需要修改司机状态、下单、记录支付日志，而每个操作都是调用了不同的服务，比如此时`hailtaxi-driver` 服务执行成功了，但是 `hailtaxi-order`有可能执行失败了，这时候如何实现跨服务事务回滚呢？这就要用到分布式事务。

## 1.1 事务简介

事务\(Transaction\)是访问并可能更新数据库中各种数据项的一个程序执行单元\(unit\)。在关系数据库中，一个事务由一组SQL语句组成。事务应该具有4个属性：**原子性、一致性、隔离性、持久性**。这四个属性通常称为**ACID**特性。

## 1.2 本地事务

大多数场景下，我们的应用都只需要操作单一的数据库，这种情况下的事务称之为本地事务\( LocalTransaction \)。本地事务的ACID特性是数据库直接提供支持。本地事务应用架构如下所示：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d52b0cf7e3bd4072bde6935be0926f38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
很多java应用都整合了spring，并使用其声明式事务管理功能来完成事务功能。一般使用的步骤如下：  
1、**配置事务管理器**。spring提供了一个 `PlatformTransactionManager`接口，其有2个重要的实现类：

1.  `DataSourceTransactionManager` :用于支持**本地事务**,事实上,其内部也是通过操作`java.sql.Connection`来开启、提交和回滚事务。
2.  `JtaTransactionManager` ：用于支持**分布式事务**，其实现了JTA规范，使用XA协议进行两阶段提交。需要注意的是，这只是一个代理，我们需要为其提供一个`JTA provider`，一般是Java EE容器提供的事务协调器\(Java EE server’s transaction coordinator\)，也可以不依赖容器，配置一个本地的JTAprovider。

2、 在需要开启的事务的bean的方法上添加 `@Transitional`注解

## 1.3 分布式事务

当下互联网发展如火如荼，绝大部分公司都进行了数据库拆分和服务化\(SOA\)。在这种情况下，完成某一个业务功能可能需要横跨多个服务，操作多个数据库。这就涉及到到了分布式事务，用需要操作的资源位于多个资源服务器上，而应用需要保证对于多个资源服务器的数据的操作，要么全部成功，要么全部失败。**本质上来说，分布式事务就是为了保证不同资源服务器的数据一致性。**

### 1.3.1 跨库事务

跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。下图演示了一个服务同时操作2个库的情况：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/ad1c8d0580984d93a260524a5ef7d1aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)

### 1.3.2 分库分表事务

通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。如下图，将数据库B拆分成了2个库：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d3d61fa9989f4dc49ee6802daab21331.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低sql操作的复杂性。如，对于`sql： insert into user(id,name) values (1,"gupaoedu"),(2,"gpvp")`。这条sql是操作单库的语法，单库情况下，可以保证事务的一致性。

但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条sql，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此基本上所有的数据库中间件都面临着分布式事务的问题。

### 1.3.3 跨应用事务

微服务架构是目前一个比较一个比较火的概念。例如上面提到的一个案例，某个应用同时操作了9个库，这样的应用业务逻辑必然非常复杂，对于开发人员是极大的挑战，应该拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过RPC框架来进行远程调用，实现彼此的通信。下图演示了一个3个服务之间彼此调用的架构：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/0e3d15f9e0fe42d29b63bd6df438d334.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
Service A完成某个功能需要直接操作数据库，同时需要调用Service B和Service C，而Service B又同时操作了2个数据库，Service C也操作了一个库。需要保证这些跨服务的对多个数据库的操作要不都成功，要不都失败，实际上这可能是最典型的分布式事务场景。

# 2、分布式理论

分布式事务可以有多种分类，比如柔性事务和强一致性事务，这些事务操作会遵循一定的定理，比如CAP原理、BASE理论。

## 2.1 CAP原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/b6270119abce4628aee9d036029e15cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
由于对系统或者数据进行了拆分，我们的系统不再是单机系统，而是分布式系统，针对分布式系统的  
CAP原理包含如下三个元素：

- **C:Consistency**，一致性。在分布式系统中的所有数据 备份，在同一时刻具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本。
- **A:Availability**，可用性，好的响应性能。完全的可用性指的是在任何故障模型下，服务都会在有限的时间内处理完成并进行响应。
- **P: Partition tolerance**，分区容忍性。尽管网络上有部分消息丢失，但系统仍然可继续工作。

CAP原理指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。而对于分布式数据系统，**分区容忍性（P）是基本要求**，否则就失去了价值。因此设计分布式数据系统，就是在一致性（C）和可用性（A）之间取一个平衡。对于大多数web应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是目前多数分布式数据库产品的方向。

当然，牺牲一致性，并不是完全不管数据的一致性，否则数据是混乱的。其只是不再要求关系型数据库中的强一致性，而是只要系统能达到最终一致性即可，考虑到客户体验，这个最终一致的时间窗口，要尽可能的对用户透明。

## 2.2 BASE理论

BASE理论是指，Basically Available（基本可用）、Soft-state（ 软状态/柔性事务）、EventualConsistency（最终一致性）。是基于CAP定理演化而来，是对CAP中一致性和可用性权衡的结果。核心思想：即使无法做到强一致性，但每个业务根据自身的特点，采用适当的方式来使系统达到**最终一致  
性。**

**1、基本可用 BA：（Basically Available ）：**  
指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用。但不等价于不可用。比如：搜索引擎0.5秒返回查询结果，但由于故障，2秒响应查询结果；网页访问过大时，部分用户提供降级服务等。简单来说就是基本可用。

**2、软状态 S：（ Soft State）：**  
软状态是指允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。即允许系统在不同节点间副本同步的时候存在延时。简单来说就是状态可以在一段时间内不同步。

**3、最终一致性 E：（Eventually Consistent）：**  
系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。简单来说就是在一定的时间窗口内， 最终数据达成一致即可。

## 2.3 刚柔事务

何谓刚柔事务？刚性事务它的事务是原子的，要么都成功要么都失败，也就是需要保障ACID理论，而柔性事务只需要保障数据最终一致即可，需要遵循  
BASE理论。

- 刚性事务满足ACID理论
- 柔性事务满足BASE理论（基本可用，最终一致）

**柔性事务分为：**

- 两阶段型
- 补偿型
- 异步确保型
- 最大努力通知型。

# 3、常用事务解决方案模型

分布式事务解决方案几乎都是柔性事务，常见的有2PC/3PC、TCC、MQ最终一致性解决方案，至于工作中用哪种方案，需要根据业务场景选取，2PC/3PC、TCC 数据强一致性高，而MQ是最终数据一致。

## 3.1 DTP模型

DTP模型中有5个基本元素：

1.  应用程序\(Application Program ，简称AP\)：用于定义事务边界\(即定义事务的开始和结束\)，并且在事务边界内对资源进行操作。
2.  资源管理器\(Resource Manager，简称RM\)：如数据库、文件系统等，并提供访问资源的方式。
3.  事务管理器\(Transaction Manager ，简称TM\)：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。
4.  通信资源管理器\(Communication Resource Manager，简称CRM\)：控制一个TM域\(TM domain\)内或者跨TM域的分布式应用之间的通信。
5.  通信协议\(Communication Protocol，简称CP\)：提供CRM提供的分布式应用节点之间的底层通信服务。

## 3.2 2PC/3PC

### 2PC

两阶段提交又称2PC,2PC是一个非常经典的 `强一致、中心化的原子提交协议`。

这里所说的中心化是指协议中有两类节点：一个是中心化 `协调者节点 （coordinator）`和 `N个参与者节点（partcipant）`。

两个阶段分别为：第一阶段：**投票阶段** 和第二阶段：**提交/执行阶段**。

例如：**订单服务A**，需要调用 **支付服务B** 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。那么看2PC阶段是如何处理的：

**第一阶段：**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/300c16760c3a4e198be80d41b7f54444.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
**①事务询问**  
协调者 向所有的 参与者 发送事务预处理请求，称之为Prepare，并开始等待各 参与者 的响应。

**②执行本地事务**  
各个 参与者 节点执行本地事务操作,但在执行完成后并**不会真正提交数据库本地事务**，而是先向 协调者报告说：“我这边可以处理了/我这边不能处理”。

**③各参与者向协调者反馈事务询问的响应**  
如果 参与者 成功执行了事务操作,那么就反馈给协调者 Yes 响应,表示事务可以执行,如果没有 参与者 成功执行事务,那么就反馈给协调者 No 响应,表示事务不可以执行。

第一阶段最终看起来就是投票yes或者no，所以又称为投票阶段

**第二阶段：**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e076c2ca0cfe4720befc8ce3b6eb2da0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
**①所有的参与者反馈给协调者的信息都是Yes,那么就会执行事务提交**  
协调者 向 所有参与者 节点发出Commit请求.

**② 事务提交**  
参与者 收到Commit请求之后,就会正式执行本地事务Commit操作,并在完成提交之后释放整个事务执行期间占用的事务资源。

### 3PC

三阶段提交又称3PC，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，这样相对有效地解决了协调者单点故障的问题。下面为三阶段提交的流程：

**第一阶段：**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/7849857c6ff947079e06c5ef24cc1982.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
这个阶段类似于**2PC**中的第二个阶段中的Ready阶段，是一种事务询问操作，事务的协调者向所有参与者询问“你们是否可以完成本次事务？”，如果参与者节点认为自身可以完成事务就返回“YES”，否则“NO”。而在实际的场景中参与者节点会对自身逻辑进行事务尝试，简单来说就是检查下自身状态的健康性，看有没有能力进行事务操作。

**第二阶段：**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/8d5e4f33107742f381397c571c4f36c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
在阶段一中，如果所有的参与者都返回Yes的话，那么就会进入PreCommit阶段进行事务预提交。此时分布式事务协调者会向所有的参与者节点发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。

如果阶段一中有任何一个参与者节点返回的结果是No响应，或者协调者在等待参与者节点反馈的过程中超时（2PC中只有协调者可以超时，参与者没有超时机制）。整个分布式事务就会中断，协调者就会向所有的参与者发送\*\*“abort”\*\* 请求。

**第三阶段：**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e510e0b5eeaa4c77a3d1db5c4ef4658b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从`“预提交状态”--->“提交状态”`。然后向所有的参与者节点发送"doCommit"请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者Ack消息后完成事务。

相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。

### 2PC VS 3PC

相比较2PC而言，3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而2PC只有协调者才拥有超时机制。这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题。

另外，通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。

## 3.3 TCC

TCC与2PC、3PC一样，也是分布式事务的一种实现方案。TCC（Try-Confirm-Cancel）又称补偿事务。其核心思想是：“针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）”。它分为三个操作：

- Try阶段：主要是对业务系统做检测及资源预留。
- Confirm阶段：确认执行业务操作。
- Cancel阶段：取消执行业务操作。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d20c89661b38445288a60e6b204ec2cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
TCC事务的处理流程与两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。

不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。

## 3.4 MQ分布式事务

如果对数据一致性要求很高，可以采用上面的2PC或者3PC以及TCC方案，如果数据强一致性要求没那么高，可以采用消息中间件（MQ）实现事务最终一致。

在支付系统中，常常使用的分布式事务解决方案就是基于MQ实现的，它对数据强一致性要求没那么高，但要求数据最终一致即可。例如：向花呗申请借钱，花呗审核通过后支付宝的余额才会增加，但花呗和支付宝有可能不是同一个系统，这时候如何实现事务呢？实现方案如下图：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/07f997e8934243a6b31c2bf6b299e8e9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16)  
上图执行流程：  
1:找花呗借钱  
2:花呗借钱审核通过，同步生成借款单  
3:借款单生成后，向MQ发送消息，通知支付宝转账  
4:支付宝读取MQ消息，并增加账户余额

上图最复杂的其实是如何保障2、3在同一个事务中执行（本地事务和MQ消息发送在同一个事务执行），借款结束后，借呗数据处理就完成了，接下来支付宝才能读到消息，然后执行余额增加，这才完成整个操作。如果中途操作发生异常，例如支付宝余额增加发生问题怎么办？此时需要人工解决，没有特别好的办法，但这种事故概率极低。